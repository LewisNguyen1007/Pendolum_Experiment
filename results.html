<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Pendulum Attention Experiment – Results Dashboard</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- jStat for t-test -->
  <script src="https://cdn.jsdelivr.net/npm/jstat@1.9.6/dist/jstat.min.js"></script>

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .card { border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.06); }
    .chart-box { height: 420px; }
    .muted { color: #64748b; }
    .badge { font-size: 11px; padding: 2px 8px; border-radius: 999px; background:#eef2ff; color:#3730a3; }
    .btn { padding: 10px 14px; border-radius: 10px; background:#1d4ed8; color:#fff; font-weight:600; }
    .btn:hover { background:#1e40af; }
    .pill { border-radius: 999px; background:#f1f5f9; padding:2px 10px; font-size:12px; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .btn-ghost { padding: 8px 12px; border-radius: 10px; background:#f1f5f9; color:#0f172a; font-weight:600; }
    .btn-ghost:hover { background:#e2e8f0; }
  </style>
</head>
<body class="bg-slate-50 min-h-screen p-4 md:p-8">
  <div class="max-w-6xl mx-auto space-y-6">

    <header class="flex items-start justify-between gap-4">
      <div>
        <h1 class="text-2xl md:text-3xl font-bold text-slate-900">Pendulum Attention Experiment – Results</h1>
        <p class="muted mt-1 text-sm">
          Raw counts use filtered submissions. Ratio-based charts & tests apply
          <span class="code">per-session exclusion</span>: values with Streak Ratio &gt; <span class="code">1.2</span>
          are omitted for that session only (other sessions for the same user are kept).
        </p>
      </div>
      <div class="text-right">
        <div class="badge">Dashboard</div>
        <div class="mt-1 text-xs text-slate-500">Auto-refresh on reload</div>
      </div>
    </header>

    <!-- Session config -->
    <section class="card bg-white p-5">
      <div class="flex flex-wrap gap-3 items-center">
        <div class="pill">Exclusion rule: per-session &gt; 1.2 (drop the value, keep the user)</div>
      </div>
    </section>

    <!-- FILTERS BLOCK -->
    <section class="card bg-white p-5">
      <div class="flex flex-col md:flex-row md:items-end gap-4">
        <!-- Session Filter -->
        <div class="flex-1">
          <label for="sessionFilter" class="block text-sm font-medium text-gray-700 mb-2">
            Session filter
          </label>
          <select id="sessionFilter" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="all" selected>All Sessions</option>
            <option value="0">Session 0</option>
            <option value="1">Session 1</option>
            <option value="2">Session 2</option>
          </select>
        </div>
        <!-- Date Filter -->
        <div class="flex-1">
          <label for="dateFilter" class="block text-sm font-medium text-gray-700 mb-2">
            Date filter
          </label>
          <select id="dateFilter" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="all" selected>All Days</option>
            <!-- dates filled dynamically -->
          </select>
        </div>
        <!-- Apply -->
        <div class="md:w-auto">
          <button id="applyBtn" class="btn w-full md:w-auto">Apply Filters</button>
        </div>
        <!-- Quick reset -->
        <div class="md:w-auto">
          <button id="resetBtn" class="btn-ghost w-full md:w-auto">Reset</button>
        </div>
      </div>
      <div id="filterNote" class="text-xs muted mt-3"></div>
    </section>

    <!-- Loading / Error / Empty -->
    <section id="stateBox" class="card bg-white p-6">
      <div id="loading" class="text-center">
        <div class="text-slate-600">Loading data…</div>
      </div>
      <div id="error" class="hidden text-center text-red-600 font-medium">Failed to load data. Check Script URL & permissions.</div>
      <div id="empty" class="hidden text-center text-slate-600">No data yet.</div>
    </section>

    <!-- Charts -->
    <section id="charts" class="hidden space-y-6">
      <!-- Raw Histogram -->
      <div class="card bg-white p-5">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Histogram — Raw Max Streak (by Session)</h2>
          <span class="muted text-xs">Filtered submissions (no ratio exclusion)</span>
        </div>
        <div class="chart-box"><canvas id="rawHist"></canvas></div>
      </div>

      <!-- Ratio Histogram -->
      <div class="card bg-white p-5">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Histogram — Streak Ratio (by Session)</h2>
          <span class="muted text-xs">Per-session exclusion (ratio &gt; 1.2 removed)</span>
        </div>
        <div class="chart-box"><canvas id="ratioHist"></canvas></div>
      </div>

      <!-- Line Chart OR Message -->
      <div class="card bg-white p-5">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Trajectory — Streak Ratio per User (S0 → S1 → S2)</h2>
          <span class="muted text-xs">Each user is a faint line; bold line = mean</span>
        </div>
        <div id="lineMsg" class="hidden text-sm text-slate-600 p-4 bg-slate-50 rounded-lg">
          Not available for this filter (requires ≥2 sessions with valid data).
        </div>
        <div id="lineWrap" class="chart-box"><canvas id="lineChart"></canvas></div>
      </div>
    </section>

    <!-- Significance tests -->
    <section id="tests" class="hidden card bg-white p-5">
      <div class="flex items-center justify-between mb-4">
        <h2 class="text-lg font-semibold">Paired Significance Tests</h2>
        <span class="muted text-xs">Per-session exclusion; pairs require valid values in both sessions</span>
      </div>

      <div id="testsControls" class="flex flex-wrap gap-3">
        <button id="btnS1S0" class="btn">Compare S1 vs S0</button>
        <button id="btnS2S0" class="btn">Compare S2 vs S0</button>
        <button id="btnS2S1" class="btn">Compare S2 vs S1</button>
      </div>

      <div id="testsMsg" class="hidden text-sm text-slate-600 p-3 bg-slate-50 rounded-lg">
        Not available under current filter (requires ≥2 sessions with valid paired data).
      </div>

      <div id="testOutput" class="mt-4 text-sm"></div>
      <div class="mt-2 text-xs muted">
        Stars: * p &lt; .05, ** p &lt; .01, *** p &lt; .001
      </div>
    </section>

    <!-- Footer -->
    <footer class="text-center muted text-xs pt-4">
      Data source: Google Apps Script Web App (GET JSON). Refresh the page to fetch the latest rows.
    </footer>
  </div>

  <script>
    // === CONFIG ===
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzuw5IezdEavu7NrQfAYu_1asHO-27lBXVhv550bLgjY63R8SJJMYAWaBKNoyFnu7RH/exec";

    // Session → videoLength, cycleTime, maxCycles
    const SESSION_CYCLE_CONFIG = {
      0: { videoLength: 24, cycleTime: 3.0, maxCycles: 8  },
      1: { videoLength: 58, cycleTime: 4.0, maxCycles: 33 },
      2: { videoLength: 27, cycleTime: 3.5, maxCycles: 10 }
    };

    // Per-session ratio exclusion threshold
    const RATIO_CUTOFF = 1.2;

    // DOM
    const $loading   = document.getElementById('loading');
    const $error     = document.getElementById('error');
    const $empty     = document.getElementById('empty');
    const $stateBox  = document.getElementById('stateBox');
    const $charts    = document.getElementById('charts');
    const $tests     = document.getElementById('tests');
    const $testOut   = document.getElementById('testOutput');

    const $sessionFilter = document.getElementById('sessionFilter');
    const $dateFilter    = document.getElementById('dateFilter');
    const $applyBtn      = document.getElementById('applyBtn');
    const $resetBtn      = document.getElementById('resetBtn');
    const $filterNote    = document.getElementById('filterNote');

    const $lineMsg  = document.getElementById('lineMsg');
    const $lineWrap = document.getElementById('lineWrap');
    const $testsMsg = document.getElementById('testsMsg');
    const $testsControls = document.getElementById('testsControls');

    // Chart refs
    let rawHistChart = null, ratioHistChart = null, lineChart = null;

    // Data cache
    let ALL_ROWS = [];      // raw rows from GAS
    let ALL_DATES = [];     // unique dates
    let CURRENT_FILTER = { session: 'all', date: 'all' };

    // Init
    window.addEventListener('load', init);

    async function init() {
      try {
        const res = await fetch(`${SCRIPT_URL}?t=${Date.now()}`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const rows = await res.json(); // [UserID, Session, MaxStreak, Timestamp, Date]
        if (!Array.isArray(rows) || rows.length === 0) return showEmpty();

        ALL_ROWS = rows.map(r => ({
          userID: String(r[0]).trim(),
          session: Number(r[1]),
          maxStreak: Number(r[2]),
          date: String(r[4] || '').trim()
        })).filter(r => r.userID && [0,1,2].includes(r.session) && Number.isFinite(r.maxStreak));

        if (ALL_ROWS.length === 0) return showEmpty();

        // Build date options
        ALL_DATES = Array.from(new Set(ALL_ROWS.map(r => r.date).filter(Boolean))).sort(dateSortDDMMYYYY);
        populateDateFilter(ALL_DATES);

        // First render with defaults (All/All)
        $stateBox.classList.add('hidden');
        $charts.classList.remove('hidden');
        $tests.classList.remove('hidden');

        applyFiltersAndRender();

        // Buttons
        $applyBtn.onclick = () => applyFiltersAndRender();
        $resetBtn.onclick = () => {
          $sessionFilter.value = 'all';
          $dateFilter.value = 'all';
          CURRENT_FILTER = { session: 'all', date: 'all' };
          applyFiltersAndRender();
        };

      } catch (e) {
        console.error(e);
        showError();
      }
    }

    function showEmpty() {
      $loading.classList.add('hidden');
      $error.classList.add('hidden');
      $empty.classList.remove('hidden');
    }
    function showError() {
      $loading.classList.add('hidden');
      $empty.classList.add('hidden');
      $error.classList.remove('hidden');
    }

    // Populate date dropdown (keep "All Days" as first option)
    function populateDateFilter(dates) {
      while ($dateFilter.options.length > 1) $dateFilter.remove(1);
      dates.forEach(d => {
        const opt = document.createElement('option');
        opt.value = d;
        opt.textContent = d;
        $dateFilter.appendChild(opt);
      });
    }

    // Main filter + render
    function applyFiltersAndRender() {
      CURRENT_FILTER.session = $sessionFilter.value; // 'all' | '0'|'1'|'2'
      CURRENT_FILTER.date    = $dateFilter.value;    // 'all' | 'dd/MM/yyyy'

      // Subset rows by filter
      const subset = ALL_ROWS.filter(r => {
        const okSession = (CURRENT_FILTER.session === 'all') ? true : String(r.session) === CURRENT_FILTER.session;
        const okDate    = (CURRENT_FILTER.date === 'all') ? true : r.date === CURRENT_FILTER.date;
        return okSession && okDate;
      });

      // Filter note
      const sTxt = (CURRENT_FILTER.session === 'all') ? 'All Sessions' : `Session ${CURRENT_FILTER.session}`;
      const dTxt = (CURRENT_FILTER.date === 'all') ? 'All Days' : CURRENT_FILTER.date;
      $filterNote.textContent = `Current filter → Session: ${sTxt} | Date: ${dTxt}`;

      if (subset.length === 0) {
        destroyCharts();
        renderNoDataState();
        return;
      }

      // Raw-by-session (for raw histogram)
      const rawBySession = { 0: [], 1: [], 2: [] };
      subset.forEach(r => rawBySession[r.session].push(r.maxStreak));

      // Ratios (per-session exclusion) & valid users
      const { validUsers, ratioByUser } = buildRatiosAndValidUsers(subset);

      // Sessions present among valid values
      const sessionsPresent = sessionCoverage(ratioByUser, validUsers);
      const nSessionsPresent = Object.keys(sessionsPresent).length;

      // Render Raw Histogram (always)
      renderRawHistogram(rawBySession);

      // Ratio Histogram (valid values only)
      if (validUsers.length === 0) {
        destroyRatioHist();
        renderEmptyRatioHistogram();
      } else {
        renderRatioHistogram(ratioByUser, validUsers);
      }

      // Line chart + Tests availability
      if (nSessionsPresent < 2 || validUsers.length === 0) {
        destroyLineChart();
        $lineMsg.classList.remove('hidden');
        $lineWrap.classList.add('hidden');

        $testsControls.classList.add('hidden');
        $testsMsg.classList.remove('hidden');
        $testOut.innerHTML = '';
      } else {
        $lineMsg.classList.add('hidden');
        $lineWrap.classList.remove('hidden');
        renderLineChart(ratioByUser, validUsers);

        $testsControls.classList.remove('hidden');
        $testsMsg.classList.add('hidden');

        document.getElementById('btnS1S0').onclick = () => runPairedTest(ratioByUser, validUsers, 1, 0);
        document.getElementById('btnS2S0').onclick = () => runPairedTest(ratioByUser, validUsers, 2, 0);
        document.getElementById('btnS2S1').onclick = () => runPairedTest(ratioByUser, validUsers, 2, 1);
        $testOut.innerHTML = '';
      }
    }

    function renderNoDataState() {
      destroyCharts();
      const ctx1 = document.getElementById('rawHist').getContext('2d');
      rawHistChart = new Chart(ctx1, { type:'bar', data:{labels:[],datasets:[]}, options:{plugins:{title:{display:true,text:'No data for current filter'}}}});
      const ctx2 = document.getElementById('ratioHist').getContext('2d');
      ratioHistChart = new Chart(ctx2, { type:'bar', data:{labels:[],datasets:[]}, options:{plugins:{title:{display:true,text:'No valid users for current filter'}}}});
      destroyLineChart();
      $lineMsg.classList.remove('hidden');
      $lineWrap.classList.add('hidden');
      $testsControls.classList.add('hidden');
      $testsMsg.classList.remove('hidden');
      $testOut.innerHTML = '';
    }

    // *** UPDATED: per-session exclusion (do NOT drop the whole user) ***
    function buildRatiosAndValidUsers(rowsSubset) {
      // Group by user
      const byUser = {};
      rowsSubset.forEach(r => {
        if (!byUser[r.userID]) byUser[r.userID] = {};
        byUser[r.userID][r.session] = r.maxStreak;
      });

      // Compute ratios; if ratio > cutoff → set NaN for that session only
      const ratioByUser = {};
      const validUsers = [];
      for (const uid of Object.keys(byUser)) {
        const map = byUser[uid];
        const ratios = {};
        [0,1,2].forEach(s => {
          if (map[s] != null) {
            const ratio = map[s] / SESSION_CYCLE_CONFIG[s].maxCycles;
            ratios[s] = (ratio > RATIO_CUTOFF) ? NaN : ratio;
          }
        });
        // keep user if they have at least one finite ratio
        const hasAnyValid = [0,1,2].some(s => Number.isFinite(ratios[s]));
        if (hasAnyValid) validUsers.push(uid);
        ratioByUser[uid] = ratios;
      }
      return { validUsers, ratioByUser };
    }

    function sessionCoverage(ratioByUser, validUsers) {
      const present = {};
      [0,1,2].forEach(s => {
        for (const uid of validUsers) {
          const v = ratioByUser[uid] && ratioByUser[uid][s];
          if (Number.isFinite(v)) { present[s] = true; break; }
        }
      });
      return present;
    }

    // ---- CHART RENDERERS ----
    function destroyCharts() { destroyRawHist(); destroyRatioHist(); destroyLineChart(); }
    function destroyRawHist(){ if (rawHistChart) { rawHistChart.destroy(); rawHistChart = null; } }
    function destroyRatioHist(){ if (ratioHistChart) { ratioHistChart.destroy(); ratioHistChart = null; } }
    function destroyLineChart(){ if (lineChart) { lineChart.destroy(); lineChart = null; } }

    function renderRawHistogram(rawBySession) {
      destroyRawHist();

      const MAX_STREAK = 40; // x-axis limit for raw Max Streak
      const labels = Array.from({length: MAX_STREAK}, (_, i) => String(i+1));
      const colors = [
        'rgba(59,130,246,0.6)',  // S0 blue
        'rgba(16,185,129,0.6)',  // S1 green
        'rgba(234,179,8,0.6)'    // S2 amber
      ];
      const borders = [
        'rgba(59,130,246,1)',
        'rgba(16,185,129,1)',
        'rgba(234,179,8,1)'
      ];
      const datasets = [0,1,2].map(s => {
        const counts = new Array(MAX_STREAK).fill(0);
        for (const v of (rawBySession[s] || [])) {
          if (Number.isFinite(v) && v>=1 && v<=MAX_STREAK) counts[v-1]++;
        }
        return {
          label: `Session ${s}`,
          data: counts,
          backgroundColor: colors[s],
          borderColor: borders[s],
          borderWidth: 1,
          borderRadius: 4
        };
      });

      const ctx = document.getElementById('rawHist').getContext('2d');
      rawHistChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
            x: { title: { display: true, text: 'Max Streak (raw count)' } },
            y: { beginAtZero: true, ticks: { stepSize: 1 }, title: { display: true, text: 'Number of respondents' } }
          }
        }
      });
    }

    function renderRatioHistogram(ratioByUser, validUsers) {
      destroyRatioHist();

      const perSession = { 0: [], 1: [], 2: [] };
      for (const uid of validUsers) {
        const rmap = ratioByUser[uid];
        [0,1,2].forEach(s => {
          const v = rmap[s];
          if (Number.isFinite(v)) perSession[s].push(v);  // already excluded > cutoff
        });
      }

      // Bins 0.0 .. 1.2
      const edges = []; for (let b=0; b<=12; b++) edges.push(b/10);
      const labels = edges.map(v => v.toFixed(1));
      const colors = [
        'rgba(59,130,246,0.6)',
        'rgba(16,185,129,0.6)',
        'rgba(234,179,8,0.6)'
      ];
      const borders = [
        'rgba(59,130,246,1)',
        'rgba(16,185,129,1)',
        'rgba(234,179,8,1)'
      ];

      const datasets = [0,1,2].map(s => {
        const counts = new Array(edges.length).fill(0);
        for (const v of perSession[s]) {
          const idx = Math.min(edges.length-1, Math.floor(v*10+1e-9));
          counts[idx]++;
        }
        return {
          label: `Session ${s}`,
          data: counts,
          backgroundColor: colors[s],
          borderColor: borders[s],
          borderWidth: 1,
          borderRadius: 4
        };
      });

      const ctx = document.getElementById('ratioHist').getContext('2d');
      ratioHistChart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: {
            x: { title: { display: true, text: 'Streak Ratio (MaxStreak / maxCycles)' } },
            y: { beginAtZero: true, ticks: { stepSize: 1 }, title: { display: true, text: 'Number of respondents' } }
          }
        }
      });
    }

    function renderEmptyRatioHistogram() {
      destroyRatioHist();
      const ctx = document.getElementById('ratioHist').getContext('2d');
      ratioHistChart = new Chart(ctx, {
        type: 'bar',
        data: { labels: [], datasets: [] },
        options: {
          responsive: true, maintainAspectRatio: false,
          plugins: { title: { display: true, text: 'No valid users for current filter' } }
        }
      });
    }

    function renderLineChart(ratioByUser, validUsers) {
      destroyLineChart();

      const labels = ['S0','S1','S2'];
      const userDatasets = [];

      for (const uid of validUsers) {
        const rmap = ratioByUser[uid] || {};
        const arr = [0,1,2].map(s => (Number.isFinite(rmap[s]) ? rmap[s] : NaN));
        if (arr.every(x => isNaN(x))) continue;
        userDatasets.push({
          label: uid,
          data: arr,
          borderWidth: 1,
          pointRadius: 0,
          tension: 0.25,
          borderColor: 'rgba(100,116,139,0.35)',
          backgroundColor: 'rgba(100,116,139,0.15)',
          spanGaps: false
        });
      }

      const means = [0,1,2].map(s => {
        const vals = [];
        for (const uid of validUsers) {
          const v = ratioByUser[uid] && ratioByUser[uid][s];
          if (Number.isFinite(v)) vals.push(v);
        }
        return vals.length ? (vals.reduce((a,b)=>a+b,0)/vals.length) : NaN;
      });
      userDatasets.push({
        label: 'Mean',
        data: means,
        borderWidth: 3,
        pointRadius: 3,
        tension: 0.2,
        borderColor: 'rgba(37,99,235,1)',
        backgroundColor: 'rgba(37,99,235,0.15)'
      });

      const ctx = document.getElementById('lineChart').getContext('2d');
      lineChart = new Chart(ctx, {
        type: 'line',
        data: { labels, datasets: userDatasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: 'nearest' },
          scales: {
            y: { beginAtZero: true, suggestedMax: 1.2, title: { display: true, text: 'Streak Ratio' } },
            x: { title: { display: true, text: 'Session' } }
          },
          plugins: {
            legend: { display: true, labels: { filter: (it) => it.text === 'Mean' } }
          }
        }
      });
    }

    // ---- Tests ----
    function runPairedTest(ratioByUser, validUsers, sA, sB) {
      const A = [], B = [];
      for (const uid of validUsers) {
        const rmap = ratioByUser[uid] || {};
        const a = rmap[sA], b = rmap[sB];
        if (Number.isFinite(a) && Number.isFinite(b)) {
          A.push(a); B.push(b);
        }
      }
      if (A.length < 3) {
        $testOut.innerHTML = `<div class="text-slate-600">Not enough paired data for S${sA} vs S${sB}.</div>`;
        return;
      }

      const diffs = A.map((a,i)=> a - B[i]);
      const n = diffs.length;
      const mean = diffs.reduce((x,y)=>x+y,0)/n;
      const sd = Math.sqrt(diffs.reduce((s,x)=> s + Math.pow(x-mean,2), 0)/(n-1));
      const t = mean / (sd / Math.sqrt(n));
      const df = n - 1;
      const p = 2 * (1 - jStat.studentt.cdf(Math.abs(t), df)); // two-tailed
      const stars = pStars(p);

      $testOut.innerHTML = `
        <div class="bg-slate-50 rounded-lg p-3">
          <div><span class="font-semibold">S${sA} vs S${sB}</span> (paired t-test)</div>
          <div class="text-sm mt-1 code">n = ${n}, meanΔ = ${mean.toFixed(3)}, t(${df}) = ${t.toFixed(3)}, p = ${fmtP(p)} ${stars}</div>
        </div>
      `;
    }

    function pStars(p) {
      if (p < 0.001) return '<span class="ml-2 text-amber-600 font-semibold">***</span>';
      if (p < 0.01)  return '<span class="ml-2 text-amber-600 font-semibold">**</span>';
      if (p < 0.05)  return '<span class="ml-2 text-amber-600 font-semibold">*</span>';
      return '';
    }
    function fmtP(p) {
      if (p < 0.0001) return '&lt; 1e-4';
      return p.toFixed(4);
    }

    // ---- Utils ----
    function dateSortDDMMYYYY(a, b) {
      const pa = a.split('/'); const pb = b.split('/');
      if (pa.length !== 3 || pb.length !== 3) return a.localeCompare(b);
      const na = Number(pa[2])*10000 + Number(pa[1])*100 + Number(pa[0]);
      const nb = Number(pb[2])*10000 + Number(pb[1])*100 + Number(pb[0]);
      return na - nb;
    }
  </script>
</body>
</html>
